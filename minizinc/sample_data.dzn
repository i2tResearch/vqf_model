% Número de estaciones base; índice i. int
N = 2;

% Número de puntos en los que se harán mediciones de señal; índice k. int
M = 5;

% Distancia entre la i-ésima estación base y el k-ésimo punto de medición. float
d_ik = [| 1.5, 2.0, 3.0, 4.3, 5.1
        | 5.4, 4.0, 3.1, 2.9, 1.8 |]

% Población que demanda servicio en el punto k. int
pob_k = [100, 90, 20, 50, 80]

% Indica si dos antenas comparten el mismo Bloque de Recursos. j {1..3N}. bool
cocan_ij = [| 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
            | 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 |]

% Cantidad recursos asignados a la radiobase i. int
channels = [20, 20]

% Número de Sectores disponibles para prestar el servicio. int
maxSol = 8;

% Cardinalidad mínima deseada para el active set, se busca que en la mayoría 
% de puntos de medición la superen sin que no hacerlo represente infactibilidad. 
% Corresponde al número mínimo de sectores que deberían poder atender el servicio. int
minSol = 1;

% Umbral a partir del cual se puede definir si un punto tiene o no cobertura, dado en dBm. float
UmbCob = -70.1;

% Umbral que define el mínimo nivel permitido para la relación portadora 
% interferencia (SINR) para cada servicio. float
UmbInterf = 1;

% Número de antenas por estación base. int
P = 3; 

% Flag que indica si el punto k tiene cobertura de alguna radiobase. bool
C_k = [1, 0, 0, 1, 0]

% Azimuth de la h-ésima antena. float
AzAnt_ih = [| 0.0, 120.0, 240.0
            | 0.0, 120.0, 240.0 |]

% Elevación de la h-ésima antena. float
ElAnt_ih = [| -3.0, -3.0, -3.0
              | -3.0, -3.0, -3.0 |]

% Potencia de la h-ésima antena. float
Pot_ih = [| -40.0, -40.0, -40.0
          | -40.0, -40.0, -40.0 |]

% Cantidad de población por Sector i. Suma de la población
% en los puntos a los que le brinda cobertura el sector i, usada 
% para el cálculo del tráfico por sector. int
Pob_j = [200, 500]
